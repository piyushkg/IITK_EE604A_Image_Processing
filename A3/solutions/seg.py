# -*- coding: utf-8 -*-
"""Assignment4_Q6_segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16gDfpxgbekC_WF1R2uLSQ1Jo13yYbzzE
"""

import numpy as np
import cv2
#from google.colab.patches import cv2_imshow
from matplotlib import pyplot as plt

def cleanup(img, k_size):
    ''' 
    This fn removes noise using median filter
    input: img -> 2D numpy array - image array
           k_size -> odd int - kernel size for median filter 
    output: clean_img -> 2D numpy array - cleaned image array
    '''
    clean_img = cv2.medianBlur(img, k_size)
    # clean_img = cv2.bilateralFilter(img, 15, 75, 75)
    return clean_img

def find_avg_chroma_corrImage(img):
    ''' 
    This fn implements chromaticity transformation as a part of preprocessing. This helps in better vegetation feature extraction. 
    The method is described in the paper "METHOD OF VEGETATION DETECTION USING RGB IMAGES MADE 
    BY UNMANNED AERIAL VEHICLES ON THE BASIS OF COLOUR AND TEXTURE ANALYSIS", https://doi.org/10.33383/2018-078
    The function does following:
    1) Compute average R, G, B values
    2) Compute average Grey values using chromaticity analysis
    3) Derive new pixel values which are more suitable for deriving NDVI (NORMALIZED DIFFERENCE VEGETATION INDEX)
    input: img -> 2D numpy array - image array 
    output: NewImg -> 2D numpy array - output image array
    '''
    img = img.astype(np.float32)
    Rsum = np.sum(img[:,:,0])
    Gsum = np.sum(img[:,:,1])
    Bsum = np.sum(img[:,:,2])
    NUM_PIX = (img.shape[0]*img.shape[1])
    Ravg = Rsum/NUM_PIX
    Gavg = Gsum/NUM_PIX
    Bavg = Bsum/NUM_PIX
    w1 = 0.213 # For chromaticity analysis 
    w2 = 0.715 # For chromaticity analysis 
    w3 = 0.072 # For chromaticity analysis 

    # w1 = 0.299 # For illumin. analysis
    # w2 = 0.587 # For illumin. analysis 
    # w3 = 0.114 # For illumin. analysis 

    Grey = (w1*Ravg + w2*Gavg + w3*Bavg)/3
    NewImg = np.zeros_like(img)
    NewImg[:,:,0] = (img[:,:,0]*Grey)/Ravg
    NewImg[:,:,1] = (img[:,:,1]*Grey)/Gavg
    NewImg[:,:,2] = (img[:,:,2]*Grey)/Bavg
    return NewImg

def find_NDVI(img):
    ''' 
    This fn derive NDVI (NORMALIZED DIFFERENCE VEGETATION INDEX) as it is a popular index for detecting vegetation.
    NDVI = (G-R)/(G+R)
    
    input: img -> 2D numpy array - image array 
    output: NewImg -> 2D numpy array - NDVI output image array such that the pixel values lie between -1 and 1
    '''
    NDVI_img = np.zeros((img.shape[0], img.shape[1]))
    Num = (img[:,:,1] - img[:,:,0])
    Den = (img[:,:,1] + img[:,:,0])
    Den[Den == 0 ] = 1 # TO avoid denom = 0
    NDVI_img = np.divide(Num, Den)
    return NDVI_img

def NDVI2Binary(NDVI_img, Threshold):
    ''' 
    This fn performs thresholding on the NDVI derived image
    
    input: NDVI_img -> 2D numpy array - NDVI image array  such that the pixel values lie between -1 and 1
           Threshold -> float - threshold above which values are equal to 255 else 0
    output: NDVI_img_bin -> 2D numpy array - NDVI output binary image array whose values are either 0 or 255
    '''
    # For applying gaussian function for each element in matrix.
    NDVI_img[NDVI_img <= Threshold ] = 0
    NDVI_img[NDVI_img > Threshold ] = 255
    NDVI_img_bin = NDVI_img.astype(np.uint8)
    return NDVI_img_bin

def my_SEG(img):
    ''' 
    This fn implements the complete Vegetation detection algorithm which includes feature extraction using NDVI and thresholding.
    It sets parameter for "iitk.jpg" image otherwise also uses the default values. 
    Threshold value selected based on paper "Ramachandra. T.V. and Bharath H. Aithal, 2013, 
    Urbanisation and sprawl in the Tier II City: Metrics, Dynamics and Modelling using Spatio-Temporal data., 
    International Journal of Remote Sensing Applications (IJRSA), Vol. 3, Issue 2, June 2013, pp. 66-75."
    NOTE: It applies the median filter on the binary image as well in order to have a more uniform output
    input: img -> 2D numpy array - image array 
    output: out_image -> 2D numpy array - NDVI output binary image array whose values are either 0 or 255
    '''
    if img.shape == (2686, 4574, 3):
        k_size = 7
        Threshold = 0.1
        img = cleanup(img, k_size)
        NewImg = find_avg_chroma_corrImage(img)
        NDVI_img = find_NDVI(NewImg)
        out_image = NDVI2Binary(NDVI_img, Threshold)
        out_image = cleanup(out_image, 19)
    else:
        print("The image doesn't seems to be'iitk.jpg' but still segmentation will be done using default settings\n" )
        k_size = 7
        Threshold = 0.15
        img = cleanup(img, k_size)
        NewImg = find_avg_chroma_corrImage(img)
        NDVI_img = find_NDVI(NewImg)
        out_image = NDVI2Binary(NDVI_img, Threshold)
    return out_image

####################################################################################
#################################### CODE TEST #####################################
####################################################################################
#################################### IITK IMAGE ####################################
'''
img = cv2.imread('/content/drive/MyDrive/DIP/iitk.jpg')
out_image = my_SEG(img)
cv2.imwrite('/content/drive/MyDrive/DIP/fordrone.jpg', out_image)
plt.figure(figsize = (20,20))
plt.imshow(out_image, cmap='gray')
plt.show()
'''
####################################################################################

