# -*- coding: utf-8 -*-
"""DIP_Assign4_q2b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TeI_X4iDRe3A-9_Jw0fbdAhRfF_Wbio0
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
#from google.colab.patches import cv2_imshow
import time

"""# **Implementation of improved bilateral filter "my_BF"**

"""

def get_mat_gauss(img_seg, sigma):
    ''' 
    This fn computes range based gaussian for a given image segment. It takes 
    image segment (of size say "N X N") and sigma as input.
    This fn. does following:
    1. Converts pandas data frame to numpy array of data.
    2. separates X data (features) and Y data (target)
    3. stores sequence of feature as arranged in numpy array 
    
    input: img_seg -> 2D numpy array - image segment (size same as the kernel size)
           sigma -> float - standard deviation of the range gaussian 
    output: img_seg_gauss -> 2D numpy array - range gaussian of image segment "img_seg"
    '''
    # For applying gaussian function for each element in matrix.
    scale_fac = 1/(np.sqrt(2*np.pi) * sigma)
    img_seg_gauss = scale_fac * np.exp(-((img_seg / sigma) ** 2) * 0.5)
    return img_seg_gauss

def form_spatial_gausskernel(k_size, sig_s):
    ''' 
    This fn computes the spatial gaussian filter kernel for the given image segment.
    It takes just the kernel dimension as input
    
    input: k_size -> int - gaussian kernel dimension
           sig_s -> float - std deviation for spatial filter
    output: kernel_s -> 2D numpy array - spatial gaussian of size (k_size X k_size)
    '''
    buff = int((k_size-1)/2)
    x_s = np.linspace(-buff,buff,k_size)
    x_s = x_s.reshape(len(x_s), 1)
    x_s = np.exp(-0.5 * np.square(x_s) / np.square(sig_s))
    x_s = x_s / np.sum(x_s)
    y_s = x_s
    kernel_s = x_s.dot(y_s.T)
    return kernel_s

def form_bf_kernel(img_seg, kernel_s, sig_i):
    ''' 
    This fn computes the bilateral filter kernel for the given image segment.
    Bilateral filter is a dynamic filter and thus its kernel values changes based on the 
    pixel values of given image segment. It recieves image segment and corresponding
    spatial image kernel.
    
    input: img_seg -> 2D numpy array - image segment (size same as the kernel size)
           kernet_s -> 2D numpy array - gaussian spatial kernel of size of "img_seg"
           sig_i -> float - standard deviation of the range gaussian 
    output: img_seg_gauss -> 2D numpy array - range gaussian of image segment "img_seg"
    '''
    
    k_size = img_seg.shape[0] # Kernel size
    cent = int((k_size-1)/2) # Centre pixel index
    
    kernel_i = img_seg - img_seg[cent,cent]
    kernel_i = get_mat_gauss(kernel_i, sig_i)
    kernel_i = kernel_i / np.sum(kernel_i)

    kernel = np.multiply(kernel_i,kernel_s)
    kernel = kernel / np.sum(kernel)
    return kernel


def mybf_original_fn(image, k_size, sig_s, sig_i, mode=0):
    '''
    This fn implements bilateral filter on the "image" with a kernel size of "k_size".
    It considers stand. deviation of "sig_s" for spatial filter and "sig_i" for range filter.
    It also operates on two modes, with zero padding and without zero padding
    
    input: image -> 2D/3D numpy array - image array on which bilateral filter has to be applied
           k_size -> int - kernel dimension
           sig_s -> float - std deviation for spatial filter
           sig_i -> float - std deviation for intensity range filter
           mode -> 0 or 1 - 0 means zero padding, =1 means no zero padding
    output: out_image -> 2D/3D numpy array - image array after bilateral filter is applied
    '''
    # Checking if the image is RGB or a Gray scale image
    if len(image.shape) == 3:
        pass
    elif len(image.shape) == 2:
        image = np.reshape(image, (image.shape[0], image.shape[1], 1))
    else:
        return print("The image format looks incompatible !! It should be a grayscale or RGB image")
    
    n_chan = image.shape[2]
    
    # Checking if the Kernel size is an odd no. If its not odd program throws an error
    if k_size % 2 == 0:
        return print("Error: Kernel Size cannot be an even no.") 
    else:
        pass 
    
    # Spatial Kernel Formed here itself to avoid repetitive formation and thus time saving
    # Spatial Kernel remains unchanged for a given Kernel size
    buff = int((k_size-1)/2)
    kernel_s = form_spatial_gausskernel(k_size, sig_s)

    if mode ==1:
        n_rows = image.shape[0]
        n_cols = image.shape[1]
        out_image = np.zeros_like(image)
        for i in range(n_chan):
            for j in range(buff, n_rows-buff):
                for k in range(buff, n_cols-buff):
                    image_seg = image[j-buff:j+buff+1,k-buff:k+buff+1,i]
                    kernel = form_bf_kernel(image_seg, kernel_s, sig_i)
                    out_image[j,k,i] = np.sum(np.multiply(kernel,image_seg))       
    elif mode ==0:
        image = np.pad(image, ((buff, buff), (buff, buff), (0, 0)), mode='constant')
        n_rows = image.shape[0]
        n_cols = image.shape[1]
        out_image = np.zeros_like(image)
        for i in range(n_chan):
            for j in range(buff, n_rows-buff):
                for k in range(buff, n_cols-buff):
                    image_seg = image[j-buff:j+buff+1,k-buff:k+buff+1,i]
                    kernel = form_bf_kernel(image_seg, kernel_s, sig_i)
                    out_image[j,k,i] = np.sum(np.multiply(kernel,image_seg))
        out_image = out_image[buff : n_rows-buff,buff : n_cols-buff,:]
    else:
        return print("Mode can be either 0 or 1 only")
    out_image = out_image.astype(np.uint8)
    return out_image


def downscale_image(img, scale_frac=0.5):
    '''
    This will downscale the image "img" by a scale = "scale_frac"
    Although the function name is downscale, it can even upscale if the scale_frac is greater than 1
    
    Inputs:
    + img - 2d np array of image to be downscaled or upscaled
    + scale_frac - float - fraction less than 1 for downscaling and greater than 1 for upscaling
    
    Ouputs:
    + out_img - np array  - scaled image array
    
    Used modules:
    +  numpy 
    + cv2.resize
    
    '''
    
    width = int(img.shape[1]*scale_frac)
    height = int(img.shape[0]*scale_frac)
    dim = (width,height)
    out_img = cv2.resize(img, dim, interpolation = cv2.INTER_AREA) 
    
    return out_img

  
def my_BF(image):
    '''
    This fn implements bilateral filter on the "image". THe BF parameter will depend upon whether 
    the image np array if of "rome.jpg" or "iitk.jpg. For other images it applies default parameter values
    
    input: image -> 2D/3D numpy array - image array on which bilateral filter has to be applied
    output: out_image_BF -> 2D/3D numpy array - image array after bilateral filter is applied
    '''
    if image.shape == (1000, 1800, 3):
        sig_s = 25
        sig_i = 75
        k_size = 7
        scale_frac=0.75
        dwn_img = downscale_image(image, scale_frac)
        out_image = mybf_original_fn(dwn_img, k_size, sig_s, sig_i)
    elif image.shape == (2686, 4574, 3):
        sig_s = 25
        sig_i = 75
        k_size = 7
        scale_frac=0.75
        dwn_edge_img = downscale_image(edge_image, scale_frac)
        out_image = mybf_original_fn(image, k_size, sig_s, sig_i) 
    else:
        print("The image doesn't seems to be 'rome.jpg' or 'iitk.jpg' but still the BF will be applied using default k_size, sig_s and sig_i values\n" )
        sig_s = 25
        sig_i = 75
        k_size = 7
        scale_frac=0.75
        dwn_img = downscale_image(image, scale_frac)
        out_image = mybf_original_fn(dwn_img, k_size, sig_s, sig_i)
    out_image_BF = downscale_image(out_image, 1/scale_frac)
    return out_image_BF

####################################################################################
#################################### CODE TEST #####################################
####################################################################################
#################################### ROME IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/rome.jpg')
st1 = time.time()
image_mybf_original = my_BF(image)
ed1 = time.time()
print("Time taken = ", ed1-st1)
image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################
#################################### IITK IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/rome.jpg')
image_mybf_original = my_BF(image)

image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################

