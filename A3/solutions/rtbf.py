# -*- coding: utf-8 -*-
"""DIP_Assign4_q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1I9C-6MDzCoSfNf1IVbcWT7hmG9LY1sXN
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
#from google.colab.patches import cv2_imshow
import time

def get_mat_gauss(img_seg, sigma):
    ''' 
    This fn implements gaussian on a 2d matrix elements
    
    input: img_seg -> 2D numpy array - image or image segment 
           sigma -> float - standard deviation of the range gaussian 
    output: img_seg_gauss -> 2D numpy array - range gaussian of image segment "img_seg"
    '''
    # For applying gaussian function for each element in matrix.
    scale_fac = 1/(np.sqrt(2*np.pi) * sigma)
    img_seg_gauss = scale_fac * np.exp(-((img_seg / sigma) ** 2) * 0.5)
    return img_seg_gauss

def form_spatial_gausskernel(k_size, sig_s):
    ''' 
    This fn forms a spatial gaussian kernel of kernel size "k_size" and variance "sig_s
    
    input: k_size -> int - gaussian kernel dimension
           sig_s -> float - std deviation for spatial filter
    output: kernel_s -> 2D numpy array - spatial gaussian of size (k_size X k_size)
    '''
    buff = int((k_size-1)/2)
    x_s = np.linspace(-buff,buff,k_size)
    x_s = x_s.reshape(len(x_s), 1)
    x_s = np.exp(-0.5 * np.square(x_s) / np.square(sig_s))
    x_s = x_s / np.sum(x_s)
    y_s = x_s
    kernel_s = x_s.dot(y_s.T)
    return kernel_s

def form_k_array(n_of_k):
    ''' 
    This fn divides 0 to 255 into "n_of_k" segments and returns the array inclusive of 0 and 255
    
    input: n_of_k -> int - number of elements after division
    output: k_array -> 1D numpy array - array of length "n_of_k" inclusive of 0 and 255
    '''
    k_array = np.floor(np.linspace(0, 255, num=n_of_k)).astype(np.uint8)
    return k_array

def interpolation_weight(Im):
    '''
    This function interpolates between "Jp" and "Jpp1" using the "val".
    input: Jp -> float/int
           val -> float/int
           Jpp1 -> float/int
    output: val_upd -> float - interpolated value between Jp and Jpp1
    '''

    Im[Im <= -1] = 0
    Im[Im >= 1] = 0
    Im = np.where(Im > 0,  -Im , Im)
    Im = np.where(Im < 0,  1+Im , Im)
    return Im

def downscale_image(img, scale_frac=0.5):
    '''
    This will downscale the image "img" by a scale = "scale_frac"
    Although the function name is downscale, it can even upscale if the scale_frac is greater than 1
    
    Inputs:
    + img - 2d np array of image to be downscaled or upscaled
    + scale_frac - float - fraction less than 1 for downscaling and greater than 1 for upscaling
    
    Ouputs:
    + out_img - np array  - scaled image array
    
    '''
    width = int(img.shape[1]*scale_frac)
    height = int(img.shape[0]*scale_frac)
    dim = (width,height)
    out_img = cv2.resize(img, dim, interpolation = cv2.INTER_AREA) 
    return out_img

def rt_BF_algo(image, n_of_k, k_size, sig_s, sig_i):
    '''
    This fn computes "n_of_k" number of principle components for the "image". 
    This fn. does following in sequence:
    1) Check for RGB or Gray scale 
    2) Check if the kernel size is odd
    3) Form a spatial gaussian kernel for give kernel size and stores it
    4) Loop starts for each principle component
    5) Determine difference image, Gj, Kj, Hj, Hsj and Jj (nomenclature same as Fig 10 Durand and Dorsey paper on Fast Bilateral Filtering)

    input: image -> 2D/3D numpy array - image array
           n_of_k -> int - number of principle components
           k_size -> int (odd no.) - Kernel size
           sig_s -> float - sigma (or variance) of spatial gaussian filter
           sig_i -> float - sigma (or variance) of range gaussian filter
    output: pcomp_lst -> list - each element of list is a principle component (numpy array)
    '''
    image = image.astype(np.float32)
    image = image/255
    # Check no. 1
    # Checking if the image is RGB or a Gray scale image. If its a gray scale,
    # reshape it to add 3rd dim. of length=1
    if len(image.shape) == 3:
        pass
    elif len(image.shape) == 2:
        image = np.reshape(image, (image.shape[0], image.shape[1], 1))
    else:
        return print("The image format looks incompatible !! It should be a grayscale or RGB image")
    
    # Check no. 2
    # Checking if the Kernel size is an odd no. If its not odd program throws an error
    if k_size % 2 == 0:
        return print("Error: Kernel Size cannot be an even no.") 
    else:
        pass 
    
    n_chan = image.shape[2]

    # Spatial Kernel Formed here itself to avoid repetitive formation and thus time saving
    # Spatial Kernel remains unchanged for a given Kernel size
    buff = int((k_size-1)/2)
    kernel_s = form_spatial_gausskernel(k_size, sig_s)

    # Initializing a list with each component as principle component

    J = np.zeros_like(image)
    maxI = 255
    minI = 0
    k_array = form_k_array(n_of_k)
    k_array = k_array/255

    for pc in range(n_of_k):
        for i in range(n_chan):
            interval = (maxI - minI)/n_of_k

            Ij = minI + pc*interval
            # Ij = k_array[pc]
            # interval = k_array[pc]

            I_new = np.abs(image[:,:,i] - Ij) 
            Gj = get_mat_gauss(I_new, sig_i) # Compute Gaussian for each pixel w.r.t. sig_i
            Kj = cv2.filter2D(src=Gj, ddepth=-1, kernel=kernel_s) # Normalization Factor
            Hj = np.multiply(Gj,image[:,:,i]) # Compute H
            Hsj = cv2.filter2D(src=Hj, ddepth=-1, kernel=kernel_s)
            Jj = np.divide(Hsj, Kj) # Normalize
            J[:,:,i] = J[:,:,i] + np.multiply(Jj,interpolation_weight(np.abs(image[:,:,i] - Ij)/ interval))
    J = J*255
    J = J.astype(np.uint8)
    return J


def rt_BF(image):
    '''
    This fn implements real time bilateral filter on the "image". THe BF parameter will depend upon whether 
    the image np array if of "rome.jpg" or "iitk.jpg. For other images it applies default parameter values
    
    input: image -> 2D/3D numpy array - image array on which bilateral filter has to be applied
    output: out_image -> 2D/3D numpy array - image array after bilateral filter is applied
    '''
    if image.shape == (1000, 1800, 3):
        no_pcomp = 20
        sig_s = 2
        sig_i = 20
        k_size = 7
        # scale_frac=0.5
        # dwn_img = downscale_image(image, scale_frac)
        out_image = rt_BF_algo(image, no_pcomp, k_size, sig_s, sig_i)
    elif image.shape == (2686, 4574, 3):
        no_pcomp = 20
        sig_s = 2
        sig_i = 20
        k_size = 7
        # scale_frac=0.5
        # dwn_img = downscale_image(image, scale_frac)
        out_image = rt_BF_algo(image, no_pcomp, k_size, sig_s, sig_i) 
    else:
        print("The image doesn't seems to be 'rome.jpg' or 'iitk.jpg' but still the BF will be applied using default k_size, sig_s and sig_i values\n" )
        no_pcomp = 20
        sig_s = 2
        sig_i = 20
        k_size = 7
        # scale_frac=0.5
        # dwn_img = downscale_image(image, scale_frac)
        out_image = rt_BF_algo(image, no_pcomp, k_size, sig_s, sig_i)
    # out_image_BF = downscale_image(out_image, 1/scale_frac)
    return out_image

####################################################################################
#################################### CODE TEST #####################################
####################################################################################
#################################### ROME IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/rome.jpg')
st1 = time.time()
image_mybf_original = rt_BF(image)
ed1 = time.time()
print("Time taken = ", ed1-st1)
image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################
#################################### IITK IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/iitk.jpg')
st1 = time.time()
image_mybf_original = rt_BF(image)
ed1 = time.time()
print("Time taken = ", ed1-st1)
image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################

####################################################################################
#################################### CODE TEST #####################################
####################################################################################
#################################### ROME IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/rome.jpg')
st1 = time.time()
image_mybf_original = rt_BF(image)
ed1 = time.time()
print("Time taken = ", ed1-st1)
# image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################
#################################### IITK IMAGE ####################################
'''
image = cv2.imread('/content/drive/MyDrive/DIP/iitk.jpg')
st1 = time.time()
image_mybf_original = rt_BF(image)
ed1 = time.time()
print("Time taken = ", ed1-st1)
image_mybf_original_rgb = cv2.cvtColor(image_mybf_original, cv2.COLOR_BGR2RGB)
plt.figure(figsize = (20,20))
plt.imshow(image_mybf_original_rgb)
'''
####################################################################################

